"use strict";

exports.__esModule = true;
exports.setup = setup;
exports.teardown = teardown;
exports.JestDevServerError = exports.ERROR_NO_COMMAND = exports.ERROR_PORT_USED = exports.ERROR_TIMEOUT = void 0;

var _stream = _interopRequireDefault(require("stream"));

var _chalk = _interopRequireDefault(require("chalk"));

var _spawnd = _interopRequireDefault(require("spawnd"));

var _cwd = _interopRequireDefault(require("cwd"));

var _waitPort = _interopRequireDefault(require("wait-port"));

var _findProcess = _interopRequireDefault(require("find-process"));

var _util = require("util");

var _terminate = _interopRequireDefault(require("terminate"));

var _inquirer = _interopRequireDefault(require("inquirer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const DEFAULT_CONFIG = {
  debug: false,
  options: {},
  launchTimeout: 5000,
  host: null,
  port: null,
  protocol: null,
  usedPortAction: 'ask'
};
const pterminate = (0, _util.promisify)(_terminate.default);
const serverLogPrefixer = new _stream.default.Transform({
  transform(chunk, encoding, callback) {
    this.push(_chalk.default.magentaBright(`[Jest Dev server] ${chunk.toString()}`));
    callback();
  }

});
const ERROR_TIMEOUT = 'ERROR_TIMEOUT';
exports.ERROR_TIMEOUT = ERROR_TIMEOUT;
const ERROR_PORT_USED = 'ERROR_PORT_USED';
exports.ERROR_PORT_USED = ERROR_PORT_USED;
const ERROR_NO_COMMAND = 'ERROR_NO_COMMAND';
exports.ERROR_NO_COMMAND = ERROR_NO_COMMAND;

class JestDevServerError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }

}

exports.JestDevServerError = JestDevServerError;
let server;

function logProcDetection(proc, port) {
  console.log(_chalk.default.blue(`🕵️  Detecting a process "${proc.name}" running on port "${port}"`));
}

async function killProc(proc) {
  console.log(_chalk.default.yellow(`Killing process ${proc.name}...`));
  await pterminate(proc.pid);
  console.log(_chalk.default.green(`Successfully killed process ${proc.name}`));
}

function runServer(config = {}) {
  if (!config.command) {
    throw new JestDevServerError('You must define a `command`', ERROR_NO_COMMAND);
  }

  server = (0, _spawnd.default)(config.command, _extends({
    shell: true,
    env: process.env,
    cwd: (0, _cwd.default)()
  }, config.options));

  if (config.debug) {
    // eslint-disable-next-line no-console
    console.log(_chalk.default.magentaBright('\nJest dev-server output:'));
    server.stdout.pipe(serverLogPrefixer).pipe(process.stdout);
  }
}

async function outOfStin(block) {
  const {
    stdin
  } = process;
  const listeners = stdin.listeners('data');
  const result = await block();
  listeners.forEach(listener => stdin.on('data', listener));
  stdin.setRawMode(true);
  stdin.setEncoding('utf8');
  stdin.resume();
  return result;
}

async function setup(config) {
  config = _extends({}, DEFAULT_CONFIG, config);

  if (config.port) {
    const [portProcess] = await (0, _findProcess.default)('port', config.port);

    if (portProcess && portProcess.pid > 0) {
      switch (config.usedPortAction) {
        case 'ignore':
          console.log('');
          logProcDetection(portProcess, config.port);
          return;

        case 'error':
          throw new JestDevServerError(`Port ${config.port} is already used by ${portProcess.name}, please kill it first`, ERROR_PORT_USED);

        case 'kill':
          console.log('');
          logProcDetection(portProcess, config.port);
          killProc(portProcess);
          break;

        case 'ask':
          {
            console.log('');
            logProcDetection(portProcess, config.port);
            const answers = await outOfStin(() => _inquirer.default.prompt([{
              type: 'confirm',
              name: 'kill',
              message: 'Should I kill it for you?',
              default: true
            }]));

            if (answers.kill) {
              await killProc(portProcess);
            } else {
              process.exit(1);
            }

            break;
          }

        default:
          throw new JestDevServerError('Invalid `usedPortAction`, only `ignore`, `error`, `kill` and `ask` are possible');
      }
    }

    runServer(config);
    const {
      launchTimeout
    } = config;
    let timeout;
    await Promise.race([new Promise((resolve, reject) => {
      timeout = setTimeout(() => reject(new JestDevServerError(`Server has taken more than ${launchTimeout}ms to start.`, ERROR_TIMEOUT)), launchTimeout);
    }), (0, _waitPort.default)({
      host: config.host,
      output: 'silent',
      port: config.port,
      protocol: config.protocol
    })]);
    clearTimeout(timeout);
  }
}

async function teardown() {
  if (server) await server.destroy();
}